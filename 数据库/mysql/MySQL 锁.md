# 锁

> 数据库锁是为了管理并发访问数据库时的数据一致性而引入的机制。在多用户并发访问数据库的环境中，可能出现多个事务同时对相同的数据进行读取或写入，为了避免数据不一致或冲突，数据库系统采用锁机制来协调各个事务的访问。

## 锁的分类

### 事务操作分类

**1. 读-读**

​	读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么 问题，所以允许这种情况的发生。

**2. 写-写**

写-写 情况，即并发事务相继对相同的记录做出改动。

​	在这种情况下会发生 `脏写` 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 `锁` 来实现的。这个所谓 的`锁`其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的.

![image-20240118193358149](https://wang-rich.oss-cn-hangzhou.aliyuncs.com/img/image-20240118193358149.png)

​	当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候 就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联

![image-20240118193425327](https://wang-rich.oss-cn-hangzhou.aliyuncs.com/img/image-20240118193425327.png)

![image-20240118193514720](https://wang-rich.oss-cn-hangzhou.aliyuncs.com/img/image-20240118193514720.png)

**获取锁成功，或者加锁成功 :** 意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务 可以继续执行操作。

 **获取锁失败，或者加锁失败，或者没有获取到锁 :**意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务 需要等待，不可以继续执行操作。

**3. 读-写或写-读**

读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。

​	这种情况下可能发生 `脏读` 、 `不可重复读` 、 `幻读` 的问题。 各个数据库厂商对 `SQL`标准 的支持都可能不一样。比如`MySQL` 在 `REPEATABLE READ` 隔离级别上就已经 解决了 幻读 问题。

1. **脏读（Dirty Read）：**
   - **定义：** 当一个事务读取了另一个事务尚未提交的数据时，就发生了脏读。
   - **示例：** 假设事务A修改了某一行数据，但尚未提交。同时，事务B读取了被事务A修改但尚未提交的数据。如果事务A回滚，事务B读取的数据就是“脏”的，因为实际上这个数据并没有被成功修改。
2. **不可重复读（Non-repeatable Read）：**
   - **定义：** 当一个事务在读取某一行数据后，另一个事务修改了该行数据并且已经提交，导致第一个事务再次读取同一行数据时，数据不一致，就发生了不可重复读。
   - **示例：** 事务A读取了某一行数据，然后事务B修改并提交了这一行数据。当事务A再次读取同一行数据时，数据已经发生了变化，不一致。
3. **幻读（Phantom Read）：**
   - **定义：** 当一个事务按照某个条件范围内的数据进行查询，而另一个事务在该范围内插入或删除了数据并且已经提交，导致第一个事务再次查询时，发现数据量或者符合条件的数据行数发生了变化，就发生了幻读。
   - **示例：** 事务A执行了一个范围查询，返回了一些数据。然后事务B插入了一些新的符合范围条件的数据，并提交。当事务A再次执行相同的范围查询时，发现结果集中出现了之前不存在的“幻影”数据。

### 锁的角度分类

![image-20240118194811105](https://wang-rich.oss-cn-hangzhou.aliyuncs.com/img/image-20240118194811105.png)

1. **数据操作类型划分**

   1. **读锁（Shared Lock）：**
      - **概念：** 读锁是一种共享锁，允许多个事务同时持有该锁，用于读取数据。
      - **特点：** 多个事务可以同时获取并持有读锁，这意味着它们可以同时读取相同的数据，而不会相互阻塞。
      - **适用场景：** 适用于读取操作，当事务获得读锁后，其他事务也能获得读锁，从而实现并发读取。
   2. **排他锁（Exclusive Lock）：**
      - **概念：** 排他锁是一种独占锁，一次只允许一个事务持有该锁，用于写入或修改数据。
      - **特点：** 当事务持有排他锁时，其他事务无法同时持有任何锁（包括读锁和排他锁），确保事务的独占性。
      - **适用场景：** 适用于写入或修改操作，防止其他事务同时读取或写入相同的数据，确保数据的一致性。

   ```sql
   -- 读锁示例
   -- 事务1
   BEGIN TRANSACTION;
   SELECT * FROM accounts WHERE account_id = 123 FOR SHARE;
   
   -- 事务2
   BEGIN TRANSACTION;
   SELECT * FROM accounts WHERE account_id = 123 FOR SHARE;
   -- 事务2可以同时获取读锁
   
   -- 排他锁示例
   -- 事务1
   BEGIN TRANSACTION;
   UPDATE accounts SET balance = balance - 100 WHERE account_id = 123;
   -- 事务1持有排他锁
   
   -- 事务2
   BEGIN TRANSACTION;
   UPDATE accounts SET balance = balance + 100 WHERE account_id = 123;
   -- 事务2需要等待事务1释放排他锁
   ```

2. **锁粒度角度划分**

   1. **表锁**

      - **s锁，x锁**

        1. **S锁（Shared Lock）：**

        > - **概念：** S锁是一种共享锁，用于读取操作。多个事务可以同时持有共享锁，允许它们同时读取相同的数据。
        > - **特点：** 当一个事务持有S锁时，其他事务也可以持有S锁，这样它们可以并发地读取相同的数据，而不会相互阻塞。
        > - **适用场景：** 适用于读取操作，提供并发读取的能力。

        2. **X锁（Exclusive Lock）：**

        > - **概念：** X锁是一种排他锁，用于写入或修改操作。一次只允许一个事务持有X锁，确保事务的独占性。
        > - **特点：** 当一个事务持有X锁时，其他事务无法同时持有任何锁，包括S锁和X锁。这确保了在写入时的独占性，防止其他事务读取或写入相同的数据。
        > - **适用场景：** 适用于写入或修改操作，确保数据的一致性。

      - **意向锁**

        通过引入意向锁，数据库管理系统可以更有效地协调多个事务之间的锁定请求，避免死锁和提高并发性能。意向锁并不直接限制对数据的访问，而是在表级别上提供一种方式，让系统了解事务的意向，以更好地进行资源管理。

        1. **意向共享锁（Intent Shared Lock）：**

           > - 表示一个事务打算在未来对某个资源进行共享锁定。
           > - 当一个事务在某个数据行上持有共享锁时，其他事务可以获得意向共享锁，表明它们也打算在未来对该资源进行共享锁定。
           > - 用于协调多个事务对相同资源的并发读取。

        2. **意向排他锁（Intent Exclusive Lock）：**

           > - 表示一个事务打算在未来对某个资源进行排他锁定。
           > - 当一个事务在某个数据行上持有排他锁时，其他事务可以获得意向排他锁，表明它们也打算在未来对该资源进行排他锁定。
           > - 用于协调多个事务对相同资源的并发写入。

   2. **行锁**

      - Record Locks(记录锁)

        > Record Locks（记录锁）是数据库中的一种锁机制，用于保护数据库表中的记录或行。当一个事务对某一行数据进行操作（如读取、更新、删除）时，可以请求获取该行的记录锁，以防止其他事务同时对同一行进行并发操作。

      - Gap Locks(间隙锁)

        > Gap Locks（间隙锁）是数据库中的一种锁机制，用于在事务中对一个范围的数据进行操作，而不仅仅是单个记录。这种锁机制通常与多版本并发控制（MVCC）结合使用，以确保事务在操作期间不会被其他事务插入新的数据，从而保持一致性。
        >
        > 主要特点和用途：
        >
        > 1. **锁定范围：** Gap Locks锁定一个范围，而不仅仅是具体的记录。这个范围通常是两个值之间的间隙，例如，对于范围 BETWEEN 10 AND 20，Gap Locks会锁定10和20之间的间隙。
        > 2. **防止插入：** 主要用于防止在事务期间其他事务插入新的数据，保护了范围内的未来数据。
        > 3. **MVCC支持：** Gap Locks通常与多版本并发控制（MVCC）一起使用，以便在读取和写入数据的同时维持事务的隔离性。
        > 4. **适用于范围查询和唯一性约束：** 在执行范围查询或插入数据时，Gap Locks可以确保不会发生新数据插入的情况，从而保持查询结果的一致性。

        ```sql
        -- 获取间隙锁（FOR UPDATE表示获取排他锁）
        SELECT * FROM table_name WHERE column_name BETWEEN 10 AND 20 FOR UPDATE;
        
        -- 插入数据时使用Gap Locks
        -- 该语句锁定了id为15的行及其前后的间隙，防止其他事务在这个范围插入新的数据
        INSERT INTO table_name (id, column_name) VALUES (15, 'new_value');
        ```

   3. **页锁**

      > 页锁（Page Lock）是数据库中一种锁定机制，它的锁定粒度是数据库中的页（Page）。数据库的数据存储通常以页为单位，一页包含多个数据行。使用页锁时，锁会被应用于整个页，而不是单个数据行。

3. **锁的态度划分**

   > 悲观锁和乐观锁是两种不同的并发控制机制，用于处理多个事务同时访问共享资源时可能引发的并发问题。它们在处理并发性和事务隔离性上有不同的策略。

   1. **悲观锁（Pessimistic Locking）：**

      - **特点：** 悲观锁假设在事务的整个生命周期中，会有其他事务试图访问相同的资源，因此采取悲观的态度，认为在进行读取或写入时可能会发生冲突。
      - **实现方式：** 常见的实现方式是通过数据库中的锁机制，例如行级锁、表级锁、页级锁等。在事务访问共享资源时，悲观锁会直接对资源进行加锁，阻止其他事务同时访问。
      - **适用场景：** 适用于高并发、写入频繁的场景，确保事务的独占性和一致性。

      ```sql
      sqlCopy code-- 使用悲观锁的示例
      BEGIN TRANSACTION;
      SELECT * FROM table_name WHERE column_name = value FOR UPDATE;
      -- 在事务期间锁定满足条件的数据行
      ```

   2. **乐观锁（Optimistic Locking）：**

      - **特点：** 乐观锁假设在事务的大部分时间里，不会有其他事务试图访问相同的资源。因此，它采取乐观的态度，允许多个事务同时访问共享资源，但在更新时会检查是否有冲突发生。
      - **实现方式：** 常见的实现方式是通过版本控制。每个数据记录都有一个版本号，事务在读取数据时获取版本号，然后在更新时检查版本号是否发生变化。如果版本号未变化，说明在读取和更新之间没有其他事务修改过数据，可以继续更新；否则，需要处理冲突。
      - **适用场景：** 适用于读取频繁、写入较少的场景，避免了大部分时间的加锁操作，提高了并发性能。

   ```java
   javaCopy code// 使用乐观锁的示例（Java代码）
   // 版本号 version 是数据记录的一个字段
   // 读取数据时获取版本号 version
   int currentVersion = getCurrentVersionFromDatabase();
   
   // 在更新时检查版本号是否变化
   if (currentVersion == expectedVersion) {
       updateData();
   } else {
       // 处理冲突，例如回滚事务或进行重试
       handleConflict();
   }
   ```

4. **加锁方式划分**

   > 隐式锁和显式锁是两种不同的锁定机制，用于在多线程或多进程环境中协调对共享资源的访问。它们在锁的获取和释放方式上有所不同。
   >
   > 
   >
   > 选择隐式锁还是显式锁取决于具体的需求。隐式锁通常更简单易用，但灵活性较低。显式锁提供了更多的灵活性，但需要开发人员更仔细地管理锁的获取和释放，以避免死锁等问题。在实际应用中，可以根据具体场景和性能需求选择合适的锁定机制。

   1. **隐式锁（Implicit Lock）：**

      - **特点：** 隐式锁是由编程语言或运行时环境自动管理的锁。在使用隐式锁时，锁的获取和释放通常由编程语言的内部机制或运行时环境自动处理，开发人员不需要显式地调用锁的相关方法。
      - **示例：** 在某些编程语言或框架中，使用关键字 `synchronized` 可以隐式地获得对象的锁。例如，Java 中的 synchronized 块就是一种隐式锁。

      ```java
      javaCopy codesynchronized (lockObject) {
          // 隐式锁定
          // ...
      }
      // 隐式释放锁
      ```

   2. **显式锁（Explicit Lock）：**

      - **特点：** 显式锁需要开发人员显式地调用锁的方法来获取和释放锁。开发人员可以手动控制锁的粒度，更灵活地处理锁定和解锁的逻辑。
      - **示例：** 在 Java 中，可以使用 `ReentrantLock` 类来创建显式锁。开发人员需要显式地调用 `lock()` 来获取锁，以及调用 `unlock()` 来释放锁。

      ```java
      javaCopy code// 创建显式锁
      ReentrantLock lock = new ReentrantLock();
      
      // 获取锁
      lock.lock();
      try {
          // 显式锁定
          // ...
      } finally {
          // 释放锁
          lock.unlock();
      }
      ```

   **死锁**

   > 死锁是指两个或多个进程或线程互相等待对方释放资源而无法继续执行的情况。这种情况会导致系统中的一组进程或线程无法进行下去，进入无限等待的状态，形成死锁。死锁是多线程或多进程并发编程中常见的问题，需要通过合理的设计和管理锁资源来避免。

   死锁发生的条件通常包括以下四个必要条件（破坏一个即可避免死锁）：

   1. **互斥条件（Mutual Exclusion）：** 一个资源每次只能被一个进程或线程使用。如果一个进程占用了某个资源，其他进程或线程就无法同时占用该资源。
   2. **请求与保持条件（Hold and Wait）：** 进程或线程已经占用了至少一个资源，并且在请求其他资源时保持对当前资源的占用。如果一个进程在等待获取其他资源的同时保持对某个资源的占用，就可能形成死锁。
   3. **不可剥夺条件（No Preemption）：** 系统不能抢占进程或线程占用的资源。只有占用资源的进程或线程自愿释放资源，其他进程或线程才能获取。
   4. **循环等待条件（Circular Wait）：** 存在一个等待循环，即一组进程或线程相互等待彼此占用的资源。形成环路。